<?xml version="1.0" encoding="UTF-8"?>
<xs:schema targetNamespace="http://www.smpte-ra.org/ns/2136-1/2024"
  xmlns:dcml="http://www.smpte-ra.org/schemas/433/2008/dcmlTypes/"
  xmlns:ds="http://www.w3.org/2000/09/xmldsig#"
  xmlns:xs="http://www.w3.org/2001/XMLSchema"
  xmlns:clf="http://www.smpte-ra.org/ns/2136-1/2024"
  xmlns:vc="http://www.w3.org/2007/XMLSchema-versioning"
  vc:minVersion="1.1" elementFormDefault="qualified" attributeFormDefault="unqualified">
  <xs:import namespace="http://www.w3.org/2000/09/xmldsig#"/>
  <xs:import namespace="http://www.smpte-ra.org/schemas/433/2008/dcmlTypes/"/>

<!--  Process List definition  -->
<xs:element name="ProcessList" type="clf:ProcessListType"/>
<xs:complexType name="ProcessListType">
  <xs:sequence>
    <xs:element name="Profile" type="xs:string" minOccurs="0" maxOccurs="1"/>
    <xs:element name="Description" type="dcml:UserTextType" minOccurs="0" maxOccurs="unbounded"/>
    <xs:element name="InputDescriptor" type="dcml:UserTextType" minOccurs="0" maxOccurs="1"/>
    <xs:element name="OutputDescriptor" type="dcml:UserTextType" minOccurs="0" maxOccurs="1"/>
    <xs:element ref="clf:Info" minOccurs="0" maxOccurs="1"/>
    <xs:element ref="clf:ProcessNode" minOccurs="1" maxOccurs="unbounded"/>
  </xs:sequence>
  <xs:attribute name="id" type="dcml:UUIDType" use="required"/>
  <xs:attribute name="compCLFversion" type="xs:string" use="optional"/><!-- deprecated, CLF version is signalled by the schama URI -->
  <xs:attribute name="name" type="xs:string" use="optional"/>
  <xs:attribute name="inverseOf" type="dcml:UUIDType" use="optional"/>
</xs:complexType>

<!--  Info element definition  -->
<xs:element name="Info" type="clf:InfoType"/>
<xs:complexType name="InfoType">
  <xs:sequence>
    <xs:element name="AppRelease" type="dcml:UserTextType" minOccurs="0" maxOccurs="1"/>
    <xs:element name="Copyright" type="dcml:UserTextType" minOccurs="0" maxOccurs="1"/>
    <xs:element name="Revision" type="dcml:UserTextType" minOccurs="0" maxOccurs="1"/>
    <xs:element name="ACEStransformID" type="clf:URNType" minOccurs="0" maxOccurs="1"/>
    <xs:element name="ACESuserName" type="dcml:UserTextType" minOccurs="0" maxOccurs="1"/>
    <xs:element ref="clf:CalibrationInfo" minOccurs="0" maxOccurs="1"/>
    <xs:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/>
  </xs:sequence>
  <xs:anyAttribute processContents="lax"/>
</xs:complexType>

<!--  CalibrationInfo element definition  -->
<xs:element name="CalibrationInfo" type="clf:CalibrationInfoType"/>
<xs:complexType name="CalibrationInfoType">
  <xs:sequence>
    <xs:element name="DisplayDeviceSerialNum" type="dcml:UserTextType" minOccurs="0" maxOccurs="1"/>
    <xs:element name="DisplayDeviceHostName" type="dcml:UserTextType" minOccurs="0" maxOccurs="1"/>
    <xs:element name="OperatorName" type="dcml:UserTextType" minOccurs="0" maxOccurs="1"/>
    <xs:element name="CalibrationDateTime" type="dcml:UserTextType" minOccurs="0" maxOccurs="1"/>
    <xs:element name="MeasurementProbe" type="dcml:UserTextType" minOccurs="0" maxOccurs="1"/>
    <xs:element name="CalibrationSoftwareName" type="dcml:UserTextType" minOccurs="0" maxOccurs="1"/>
    <xs:element name="CalibrationSoftwareVersion" type="dcml:UserTextType" minOccurs="0" maxOccurs="1"/>
  </xs:sequence>
</xs:complexType>

<!--  ProcessNode definition  -->
<xs:element name="ProcessNode" type="clf:ProcessNodeType"/>
<xs:complexType name="ProcessNodeType" abstract="true">
  <xs:sequence>
    <xs:element name="Description" type="dcml:UserTextType" minOccurs="0" maxOccurs="unbounded"/>
  </xs:sequence>
  <xs:attribute name="id" type="dcml:UUIDType" use="required"/>
  <xs:attribute name="name" type="xs:string" use="optional"/>
  <xs:attribute name="inBitDepth" type="clf:bitDepthType" use="required"/>
  <xs:attribute name="outBitDepth" type="clf:bitDepthType" use="required"/>
</xs:complexType>

<!--  ProcessNode: LUT1D definition  -->
<xs:element name="LUT1D" type="clf:LUT1DType" substitutionGroup="clf:ProcessNode"/>
<xs:complexType name="LUT1DType">
  <xs:complexContent>
    <xs:extension base="clf:ProcessNodeType">
      <xs:sequence>
        <xs:element name="Array" type="clf:ArrayType" minOccurs="1" maxOccurs="1"/>
      </xs:sequence>
      <xs:attribute name="interpolation" use="optional" fixed="linear" type="xs:string"/>
      <xs:attribute name="rawHalfs" type="xs:string" use="optional" fixed="true"/>
      <xs:attribute name="halfDomain" type="xs:string" use="optional" fixed="true"/>
      <!-- If halfDomain=true then the Array shall be of dim="65536 1" and shall contain 65536 entries-->
      <xs:assert test="
      if (@halfDomain eq 'true')
      then (./clf:Array/@dim = '65536 1')
        and (count(tokenize(xs:token(./clf:Array),' ')) eq 65536)
      else true()
      "/>
    </xs:extension>
  </xs:complexContent>
</xs:complexType>

<!--  ProcessNode: LUT3D definition  -->
<xs:element name="LUT3D" type="clf:LUT3DType" substitutionGroup="clf:ProcessNode"/>
<xs:complexType name="LUT3DType">
  <xs:complexContent>
    <xs:extension base="clf:ProcessNodeType">
      <xs:sequence>
        <xs:element name="Array" type="clf:ArrayType" minOccurs="1" maxOccurs="1"/>
      </xs:sequence>
      <xs:attribute name="interpolation" use="optional" default="trilinear">
        <xs:simpleType>
          <xs:restriction base="xs:string">
            <xs:enumeration value="trilinear"/>
            <xs:enumeration value="tetrahedral"/>
          </xs:restriction>
        </xs:simpleType>
      </xs:attribute>
    </xs:extension>
  </xs:complexContent>
</xs:complexType>

<!--  ProcessNode: Matrix definition  -->
<xs:element name="Matrix" type="clf:MatrixType" substitutionGroup="clf:ProcessNode"/>
<xs:complexType name="MatrixType">
  <xs:complexContent>
    <xs:extension base="clf:ProcessNodeType">
      <xs:sequence>
        <xs:element name="Array" type="clf:MatrixArrayType" minOccurs="1" maxOccurs="1"/>
      </xs:sequence>
    </xs:extension>
  </xs:complexContent>
</xs:complexType>

<!--  ProcessNode: Range definition  -->
<xs:element name="Range" type="clf:RangeType" substitutionGroup="clf:ProcessNode"/>
<xs:group name="MinValueGroup">
  <xs:sequence>
    <xs:element name="minInValue" type="xs:float" minOccurs="1" maxOccurs="1"/>
    <xs:element name="minOutValue" type="xs:float" minOccurs="1" maxOccurs="1"/>
    <xs:choice minOccurs="0" maxOccurs="1">
      <xs:group ref="clf:MaxValueGroup"/>
    </xs:choice>
  </xs:sequence>
</xs:group>
<xs:group name="MaxValueGroup">
  <xs:sequence>
    <xs:element name="maxInValue" type="xs:float" minOccurs="1" maxOccurs="1"/>
    <xs:element name="maxOutValue" type="xs:float" minOccurs="1" maxOccurs="1"/>
  </xs:sequence>
</xs:group>
<xs:complexType name="RangeType">
  <xs:complexContent>
    <xs:extension base="clf:ProcessNodeType">
      <xs:sequence>
        <xs:choice minOccurs="1" maxOccurs="1">
          <xs:group ref="clf:MinValueGroup"/>
          <xs:group ref="clf:MaxValueGroup"/>
        </xs:choice>
      </xs:sequence>
      <xs:attribute name="style" use="optional" default="Clamp">
        <xs:simpleType>
          <xs:restriction base="xs:string">
            <xs:enumeration value="Clamp"/>
            <xs:enumeration value="noClamp"/>
          </xs:restriction>
        </xs:simpleType>
      </xs:attribute>
    </xs:extension>
  </xs:complexContent>
</xs:complexType>

<!--  ProcessNode: Log definition  -->
<xs:element name="Log" type="clf:LogType" substitutionGroup="clf:ProcessNode"/>
<xs:complexType name="LogType">
  <xs:complexContent>
    <xs:extension base="clf:ProcessNodeType">
      <xs:sequence>
        <xs:element name="LogParams" type="clf:LogParamsType" minOccurs="0" maxOccurs="3"/>
      </xs:sequence>
      <xs:attribute name="style" use="required">
        <xs:simpleType>
          <xs:restriction base="xs:string">
            <xs:enumeration value="log10"/>
            <xs:enumeration value="antiLog10"/>
            <xs:enumeration value="log2"/>
            <xs:enumeration value="antiLog2"/>
            <xs:enumeration value="linToLog"/>
            <xs:enumeration value="logToLin"/>
            <xs:enumeration value="cameraLinToLog"/>
            <xs:enumeration value="cameraLogToLin"/>
          </xs:restriction>
        </xs:simpleType>
      </xs:attribute>
    </xs:extension>
  </xs:complexContent>
</xs:complexType>
<xs:complexType name="LogParamsType">
  <xs:attribute name="base" type="xs:float" use="optional" default="10"/>
  <xs:attribute name="logSideSlope" type="xs:float" use="optional" default="1.0"/>
  <xs:attribute name="logSideOffset" type="xs:float" use="optional" default="0.0"/>
  <xs:attribute name="linSideSlope" type="xs:float" use="optional" default="1.0"/>
  <xs:attribute name="linSideOffset" type="xs:float" use="optional" default="0.0"/>
  <xs:attribute name="linSideBreak" type="xs:float" use="optional" default="0.0"/>
  <xs:attribute name="linearSlope" type="xs:float" use="optional"/>
  <xs:attribute name="linearOffset" type="xs:float" use="optional"/>
  <xs:attribute name="channel" type="clf:channelType" use="optional"/>
</xs:complexType>

<!--  ProcessNode: Exponent definition  -->
<xs:element name="Exponent" type="clf:ExponentType" substitutionGroup="clf:ProcessNode"/>
<xs:complexType name="ExponentType">
  <xs:complexContent>
    <xs:extension base="clf:ProcessNodeType">
      <xs:sequence>
        <xs:element name="ExponentParams" type="clf:ExponentParamsType" maxOccurs="3"/>
      </xs:sequence>
      <xs:attribute name="style" use="required">
        <xs:simpleType>
          <xs:restriction base="xs:string">
            <xs:enumeration value="basicFwd"/>
            <xs:enumeration value="basicRev"/>
            <xs:enumeration value="basicMirrorFwd"/>
            <xs:enumeration value="basicMirrorRev"/>
            <xs:enumeration value="basicPassThruFwd"/>
            <xs:enumeration value="basicPassThruRev"/>
            <xs:enumeration value="monCurveFwd"/>
            <xs:enumeration value="monCurveRev"/>
            <xs:enumeration value="monCurveMirrorFwd"/>
            <xs:enumeration value="monCurveMirrorRev"/>
          </xs:restriction>
        </xs:simpleType>
      </xs:attribute>
      <xs:assert test="
      if (count(./clf:ExponentParams) eq 1) then (
        ((substring(@style, 1, 5) = 'basic') and not(exists(./clf:ExponentParams/@offset))) or
        ((substring(@style, 1, 8) = 'monCurve')
        and exists(./clf:ExponentParams/@offset)
        and (./clf:ExponentParams/@exponent &gt;= 1.0)
        and (./clf:ExponentParams/@exponent &lt;= 10.0))
      )
      else if (count(./clf:ExponentParams) eq 3) then (
        (
          ((substring(@style, 1, 5) = 'basic') and not(exists(./clf:ExponentParams[*]/@offset))) or
          ((substring(@style, 1, 8) = 'monCurve')
          and exists(./clf:ExponentParams[1]/@offset)
          and exists(./clf:ExponentParams[2]/@offset)
          and exists(./clf:ExponentParams[3]/@offset)
          and (./clf:ExponentParams[1]/@exponent &gt;= 1.0)
          and (./clf:ExponentParams[1]/@exponent &lt;= 10.0)
          and (./clf:ExponentParams[2]/@exponent &gt;= 1.0)
          and (./clf:ExponentParams[2]/@exponent &lt;= 10.0)
          and (./clf:ExponentParams[3]/@exponent &gt;= 1.0)
          and (./clf:ExponentParams[3]/@exponent &lt;= 10.0)
          )
        ) and exists(./clf:ExponentParams[1]/@channel) 
          and exists(./clf:ExponentParams[2]/@channel) 
          and exists(./clf:ExponentParams[3]/@channel)
          and (./clf:ExponentParams[1]/@channel != ./clf:ExponentParams[2]/@channel)
          and (./clf:ExponentParams[1]/@channel != ./clf:ExponentParams[3]/@channel)
          and (./clf:ExponentParams[2]/@channel != ./clf:ExponentParams[3]/@channel)
      )
      else false()
      "/>
    </xs:extension>
  </xs:complexContent>
</xs:complexType>
<xs:complexType name="ExponentParamsType">
  <xs:attribute name="exponent" type="xs:float" use="required"/>
  <xs:attribute name="offset" use="optional">
    <xs:simpleType>
      <xs:restriction base="xs:float">
        <xs:minInclusive value="0."/>
        <xs:maxInclusive value="0.9"/>
      </xs:restriction>
    </xs:simpleType>
  </xs:attribute>
  <xs:attribute name="channel" type="clf:channelType" use="optional"/>
</xs:complexType>

<!--  ProcessNode: ASC-CDL definition  -->
<xs:element name="ASC_CDL" type="clf:ASC_CDLType" substitutionGroup="clf:ProcessNode"/>
<xs:complexType name="ASC_CDLType">
  <xs:complexContent>
    <xs:extension base="clf:ProcessNodeType">
      <xs:sequence>
        <xs:element name="SOPNode" type="clf:SOPNodeType" minOccurs="0" maxOccurs="1"/>
        <xs:element name="SatNode" type="clf:SatNodeType" minOccurs="0" maxOccurs="1"/>
      </xs:sequence>
      <xs:attribute name="style" default="Fwd">
        <xs:simpleType>
          <xs:restriction base="xs:string">
            <xs:enumeration value="Fwd"/>
            <xs:enumeration value="Rev"/>
            <xs:enumeration value="FwdNoClamp"/>
            <xs:enumeration value="RevNoClamp"/>
          </xs:restriction>
        </xs:simpleType>
      </xs:attribute>
    </xs:extension>
  </xs:complexContent>
</xs:complexType>
<xs:complexType name="SOPNodeType">
  <xs:sequence>
    <xs:element name="Slope" type="clf:positiveFloatListLength3Type" minOccurs="1" maxOccurs="1" default="1.0 1.0 1.0"/>
    <xs:element name="Offset" type="clf:floatListLength3Type" minOccurs="1" maxOccurs="1" default="0.0 0.0 0.0"/>
    <xs:element name="Power" type="clf:positiveFloatListLength3Type" minOccurs="1" maxOccurs="1" default="1.0 1.0 1.0"/>
  </xs:sequence>
</xs:complexType>
<xs:complexType name="SatNodeType">
  <xs:sequence>
    <xs:element name="Saturation" type="clf:positiveFloatType" minOccurs="0" maxOccurs="1" default="1.0"/>
  </xs:sequence>
</xs:complexType>

<!--  Data Type: ArrayType  -->
<xs:complexType name="ArrayType">
  <xs:simpleContent>
    <xs:extension base="clf:floatListType">
      <xs:attribute name="dim" type="clf:dimType" use="required"/>
      <!-- Test for number of elements in LUT1D and LUT3D -->
      <xs:assert test="
      (
      count($value) = number(substring-before(@dim, ' ')) * 
              number(substring-before(substring-after(@dim, ' '), ' ')) * 
              number(substring-before(substring-after(substring-after(@dim, ' '), ' '), ' ')) *
              number(substring-after(substring-after(substring-after(@dim, ' '), ' '), ' '))
      ) or (
      count($value) = number(substring-before(@dim, ' ')) * 
              number(substring-after(@dim, ' '))
      )
      "/>
    </xs:extension>
  </xs:simpleContent>
</xs:complexType>

<!--  Data Type: MatrixArrayType  -->
<xs:complexType name="MatrixArrayType">
  <xs:simpleContent>
    <xs:extension base="clf:ArrayType">
      <xs:attribute name="dim" use="required">
        <xs:simpleType>
          <xs:restriction base="clf:dimType">
            <xs:enumeration value="3 3"/>
            <xs:enumeration value="3 4"/>
          </xs:restriction>
        </xs:simpleType>
      </xs:attribute>
      <!-- Test for number of elements in matrices -->
      <xs:assert test="
      ((@dim = '3 3') and (count($value) = 9)) or
      ((@dim = '3 4') and (count($value) = 12))
      "/>
    </xs:extension>
  </xs:simpleContent>
</xs:complexType>

<!--  Data Type: floatListType  -->
<xs:simpleType name="floatListType">
  <xs:list itemType="xs:float"/>
</xs:simpleType>

<!--  Data Type: positiveFloatType  -->
<xs:simpleType name="positiveFloatType">
  <xs:restriction base="xs:float">
    <xs:minExclusive value="0"/>
  </xs:restriction>
</xs:simpleType>

<!--  Data Type: positiveFloatListLength3Type  -->
<xs:simpleType name="positiveFloatListLength3Type">
  <xs:restriction>
    <xs:simpleType>
      <xs:list itemType="clf:positiveFloatType"/>
    </xs:simpleType>
    <xs:length value="3"/>
  </xs:restriction>
</xs:simpleType>

<!--  Data Type: floatListLength3Type  -->
<xs:simpleType name="floatListLength3Type">
  <xs:restriction>
    <xs:simpleType>
      <xs:list itemType="xs:float"/>
    </xs:simpleType>
    <xs:length value="3"/>
  </xs:restriction>
</xs:simpleType>

<!--  Data Type: dimType  -->
<xs:simpleType name="dimType">
  <xs:restriction base="xs:string">
    <xs:minLength value="3"/>
    <xs:pattern value="[\d\s]*\d"/>
  </xs:restriction>
</xs:simpleType>

<!--  Data Type: bitDepthType  -->
<xs:simpleType name="bitDepthType">
  <xs:restriction base="xs:string">
    <xs:enumeration value="8i"/>
    <xs:enumeration value="10i"/>
    <xs:enumeration value="12i"/>
    <xs:enumeration value="16i"/>
    <xs:enumeration value="16f"/>
    <xs:enumeration value="32f"/>
  </xs:restriction>
</xs:simpleType>

<!--  Data Type: channelType  -->
<xs:simpleType name="channelType">
  <xs:restriction base="xs:string">
    <xs:pattern value="[RGB]"/>
  </xs:restriction>
</xs:simpleType>

<!--  Data Type: URNType  -->
<xs:simpleType name="URNType">
  <xs:restriction base="xs:anyURI">
    <xs:pattern value="urn:[A-Za-z0-9][A-Za-z0-9-]{0,31}:([A-Za-z0-9()+,\-.:=@;$_!*']|%[0-9A-Fa-f]{2})"/>
  </xs:restriction>
</xs:simpleType>
</xs:schema>
